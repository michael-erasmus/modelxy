---
keywords: fastai
title: Think Columns
toc: false 
badges: true
comments: true
categories: [analytics_engineering, sql]
header_image: /images/think_columns_header.jpg
header_image_alt: Lego landscape, made by Midjourney
author: Michael Erasmus
nb_path: _notebooks/2022-08-12-think-columns.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2022-08-12-think-columns.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>This is a first installment in a series of posts I plan on writing related to the basics of analytical SQL database. This content probably most useful to junior or aspriring analytics engineers.</em></p>
<p>What is a columnar database?</p>
<p>Most well known modern data warehouses (Snowflake, BigQuery, Redshift, etc) are column-oriented, or just columnar databases. This means that unlike more mainstream SQL databases, data is stored in columns instead of rows. So for any particular table in the database, all the data for a certain column will be stored sequentially.</p>
<p>Why does this matter? Well, this means that typical queries that you would need to do analysis could be much faster on huge datasets.</p>
<p>Take a very simple aggregation such as this:</p>
<div class="highlight"><pre><span></span><span class="k">select</span> <span class="k">sum</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="k">from</span> <span class="n">transactions</span>
</pre></div>
<p>Let's say you're running this on a really big database table with millions of records. In a columnar database, since all the data in the <code>amount</code> column is optimized to be stored together, this query will be much faster than on a traditional database, especially if you haven't optimized the table for doing aggregations on that field.</p>
<p>We often do a lot of these kinds of aggregations (<code>MIN</code>, <code>MAX</code>, <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>, etc) for analytics work, which columnar databases can do really well.</p>
<p>Another benefit of being columnar is that the database can optimize well for performing as much work in memory as possible, and easily distribute workloads in parallel onto a cluster of computers. In our query above, the DB engine only needs to load up data for the column <code>amount</code> to perform the count, and since it's all stored together, this is easy to do without having to scan the full rows.</p>
<p>If a table has millions or even billions of records, some columnar databases can store segments of all the data in our column on different nodes in of cluster, which can individualy compute the sum of each segement seperately, which can then be tallied into a final sum fairly quickly. In this way you can scale an operation that would have been slow or even impossible on a single machine to a cluster of machines easily.</p>
<h2 id="Why-should-care-about-if-my-database-is-columnar?">Why should care about if my database is columnar?<a class="anchor-link" href="#Why-should-care-about-if-my-database-is-columnar?"> </a></h2><p>In a lot of ways, when your using a colummar database, the database engine doesn't need you to know much about the fact that it's columnar at all. On the surface, you can access it very much like you would a row-oriented database such as PostgreSQL. At a semantic level, most database entities and queries will appear almost identical. You'll can also stick to the familiar SQL database nomenclature, using terms such as <em>tables</em>, <em>rows</em>, <em>columns</em> and <em>fields</em>.</p>
<p>Columnar databases do, however, significantly change the way you think about modeling and querying data. Even though you don't have to be concerned about the low-level details (unless you're interested), having a high-level understanding of the important concepts will help guide and inform your decisions on how you ingest, store and query your data.</p>
<p>For instance, in a columnar database, it's fine to have a huge table with many columns that might be sparsely populated. As long as your not selecting a lot of columns at once, and only performing aggregations on certain columns, this will still be super performant.</p>
<p>Since tables can have many columns, you might not need to normalize data as much, which is also a great win for analytics.</p>
<h2 id="What-are-columnar-databases-not-good-for?">What are columnar databases not good for?<a class="anchor-link" href="#What-are-columnar-databases-not-good-for?"> </a></h2><p>The flip side of all of the benefits of a columnar database is that a simple <code>select *</code> query that might only return one or a few rows can be surprisingly slow.</p>
<p>Unlike traditional SQL databases, fields related to the same row in a table might not be stored close to each other, and could often be stored in different 'slices' of your database, which could mean different machines in your cluster. So, in a query, selecting all of your table's columns for any particular row might force the database to find and put together a whole lot of scattered datapoints, which can result in a slower than expected execution time.</p>
<p>That doesn't mean that you can't write fast queries that need access to many or all of the columns in at all, it's still perfectly possible but it might mean that need spend more time thinking about how design and optimize your database.</p>
<p>This is why a columnar database won't make for a great database to power a normal web or client-server application, where you're often reading in all the columns for a small number of rows. Another reason why columnar databases aren't that great for these kinds of applications is that it's not really optimized for writing small batches of records to the database.</p>
<p>But it can perform analysis and number crunching on huge datasets incredibly quickly if you know what your doing!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Implementing-the-concept-with-code">Implementing the concept with code<a class="anchor-link" href="#Implementing-the-concept-with-code"> </a></h2><p>Let's make the concept of a column vs row oriented database more concrete by writing some code.</p>
<p>We'll build a very, very basic 'database' implementation in Python.</p>
<p>First we'll create a classic-style in-memory database table to store a list of transactions. Each 'row' is a dictionary with values for each column.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">transactions</span> <span class="o">=</span><span class="p">[</span>
    <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;customer_id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;product_id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;amount&quot;</span><span class="p">:</span> <span class="mf">9.99</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;customer_id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;product_id&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;amount&quot;</span><span class="p">:</span> <span class="mf">4.99</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;customer_id&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;product_id&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;amount&quot;</span><span class="p">:</span> <span class="mf">25.99</span><span class="p">},</span>   
<span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can 'query' our database. Let's say we want to calculate our total revenue, the sum of all the <code>amount</code> columns.
This function will loop through each transaction, read the <code>amount</code> and then sum it all together.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_total_transaction_revenue</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the total revenue from all transactions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="s2">&quot;amount&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transactions</span><span class="p">])</span>

<span class="n">get_total_transaction_revenue</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>40.97</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's benchmark this function. We create a <code>benchmark</code> function that will run our query 1 million times and see how long it takes to run.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">benchmark</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    
    <span class="kn">import</span> <span class="nn">timeit</span>
    <span class="n">num_runs</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="n">number</span> <span class="o">=</span> <span class="n">num_runs</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num_runs</span><span class="si">}</span><span class="s2"> runs took </span><span class="si">{</span><span class="n">duration</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And we run the benchmark:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">benchmark</span><span class="p">(</span><span class="n">get_total_transaction_revenue</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>1000000 runs took 1.9082819640170783 seconds
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Ok, so let's make a columnar version of our 'table'. Instead of starting from scratch I'll convert our existing <code>transactions</code> data structure.</p>
<p>The main difference to note here is that our table is now a dictionary with keys for each column, which maps to a list of values for each row.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">transactions_columnar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transactions</span><span class="p">],</span>
    <span class="s2">&quot;customer_id&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="s2">&quot;customer_id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transactions</span><span class="p">],</span>
    <span class="s2">&quot;product_id&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="s2">&quot;product_id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transactions</span><span class="p">],</span>
    <span class="s2">&quot;amount&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="s2">&quot;amount&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transactions</span><span class="p">],</span>
<span class="p">}</span>

<span class="n">transactions_columnar</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;id&#39;: [1, 2, 3],
 &#39;customer_id&#39;: [1, 1, 2],
 &#39;product_id&#39;: [1, 2, 3],
 &#39;amount&#39;: [9.99, 4.99, 25.99]}</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can build a similar 'query' function to calculate our total revenue on our column-oriented table. Instead of having to loop through each row, we can just sum up the <code>amount</code> column directly</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_total_transaction_revenue_cols</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the total revenue from all transactions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transactions_columnar</span><span class="p">[</span><span class="s2">&quot;amount&quot;</span><span class="p">])</span>

<span class="n">get_total_transaction_revenue_cols</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>40.97</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This gives us the same result as we got before.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">get_total_transaction_revenue</span><span class="p">()</span> <span class="o">==</span> <span class="n">get_total_transaction_revenue_cols</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's benchmark this function then:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">benchmark</span><span class="p">(</span><span class="n">get_total_transaction_revenue_cols</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>1000000 runs took 1.1226091338321567 seconds
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Not a massive difference, but we can show that this is a faster implementation.</p>
<p>Even on this toy example we can see the benefit of using a column-oriented datastructure for certain aggregation patterns.</p>

</div>
</div>
</div>
</div>
 

